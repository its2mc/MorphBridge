/* Morph Bridge Application module. 
Created By: Phillip Ochola Mak'Anyengo,
Email: its2uraps@gmail.com, 
Github: https://github.com/its2mc,
License: 
*/


//Channel Object. This is the King Kunta.. :D 
var channels_obj = Object.create(null);
channels_obj.channel_list = [];//Channel list

channels_obj.init = function(){
};//Initializes channel object

channels_obj.createChannel = function(channelId){
};//Adds a new channel

channels_obj.translate = function(msg,userSock){
	var tempCmd = JSON.parse(msg);
	switch (tempCmd.command) {
		case "createChannel" : 
			try{
				if(channels[tempCmd.channelId] = channel(tempCmd.pass))	console.log("Channel Creation Successful\n");
				else console.log("Channel Already exists");
			}catch(e){
				console.log("Error Has occured during channel creation \n");
			}
		break;
		
		case "destroyChannel":
			try{
				for (var i in channels)
					if(i==tempCmd.channelId) channels.splice(i,1);
				console.log("Channel Destruction Successful\n");
			}catch(e){
				console.log("Error Has occured during channel destruction\n : "+e);
			}
		break;
		
		case "subscribe" : 
			try{
				if(channels[tempCmd.channelId].subscribe(userSock))	console.log("Subscription Successful\n");
				else throw "Subscriber Already Exists";
			}catch(e){
				console.log("Error Has occured during subscription\n" + e);
			}
		break;
		
		case "unsubscribe" : 
			try{
				channels[tempCmd.channelId].unsubscribe(userSock);
				console.log("Unsubscription Successful\n");
			}catch(e){
				console.log("Error Has occured during unsubscription\n"+e);
			}
		break;
		
		case "showStats" : 
			try{
				console.log(channels[tempCmd.channelId].stats());
			}catch(e){
				console.log("The following error occured\n"+e);
			}
		break;
		
		default:
			try{ 
				channels[tempCmd.channelId].broadcast(tempCmd.data);
			}catch(e){
				console.log("The following error occured\n"+e);
			}
		break;
	}
};//This contains an optional message processor class

channels_obj.purge = function(channelId){
};//purges a channel

channels_obj.broadcast = function(channelId,msg){
};//Traditionally broadcast to all players in a channel.

channels_obj.bare_broadcast = function(){
};//Broadcast stripped down message (non JSON format) to users

channels_obj.checkTimeout = function(){
};//Checks if the timeout has been passed

channels_obj.timestamp = function(){
};

//Channel sub object
channels_obj.channel = Object.create(null);//Naked Channel Object
channels_obj.channel.timestamp = 0;//Adds a timestamp to the channel
channels_obj.channel.channelPass = '';
channels_obj.channel.subscribers = [];

channels_obj.channel.subscribe = function(){
	for(var i in this.subscribers) if(this.subscribers[i]==sock) return 0;
		this.subscribers.push(sock);
	return 1;
};//subscribe a user to a channel

channels_obj.channel.broadcast = function(){
	for (var i in this.subscribers)
		 this.subscribers[i].send(msg);
	return 1;	
};//Broadcasting a message to a specific channel

Object.freeze(channels_obj);
module.exports.channels_obj = channels_obj;


//ZMQ interproc Communication Handler
var zmq = require('zmq'),
publisher = zmq.socket('pub'),
subscriber = zmq.socket('sub'),
comms = Object.create(null);

comms.init = function(handle_func){
	this.pub_init();
	this.sub_init(handle_func);
};//Initialization function

comms.pub_init = function(){
	//if publisher already bound skip
	publisher.bind('tcp://*:8688', function(err) {
 		if(err){
    		console.log("Port already established: connecting...");
			logger.logStat("Port already established: connecting...");
			//if not then connect to bound publisher
			publisher.connect('tcp://localhost:8688',function(err){
				if(err)
					logger.logErr(err);
			});
			}
  		else
   			console.log("Listening on 8688...");
	});
};
	
comms.sub_init = function(handle_func){
	subscriber.connect('tcp://localhost:8688', function(err){
			console.log(err);
			logger.logErr(err);
		});
	subscriber.subscribe("");
	subscriber.on("message",handle_func);
	console.log("Subscribed to empty channel");
	logger.logStat("Subscribed to empty channel");
};//Subscribes to socket, the subscriber message handling will be defined 
	
comms.transmit = function(msg){
	publisher.send(msg);
	return 1;
};//Transmits messages to all nodes

Object.freeze(comms);
module.exports.comms = comms;


//Log Handler: This will manage custom error messages for platform errors.
//The messages are coded to make it lighter for smaller devics
var winston = require('winston'),
logger = Object.create(null);

var log_object = '';

logger.init = function(){
	log_object = new (winston.Logger)({
		transports: [
			new (winston.transports.File)({
				name: 'error-file',
				filename: 'logs/errors.log',
				level: 'error',
				handleExceptions: true
			}),
			new (winston.transports.File)({
				name: 'info-file',
				filename: 'logs/stats.log',
				level: 'info'
			}) 
		]
	});
};

logger.logStat = function(tmp){
	log_object.info(tmp);
};

logger.logErr = function(tmp){
	log_object.error(tmp);
};

logger.logDebug = function(tmp){
	log_object.debug(tmp);
};

Object.freeze(logger);
module.exports.logger = logger;

