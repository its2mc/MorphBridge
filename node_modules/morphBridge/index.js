/* Morph Bridge Application module. 
Created By: Phillip Ochola Mak'Anyengo,
Email: its2uraps@gmail.com, 
Github: https://github.com/its2mc,
License: 
*/


//Channel Object. This is the King Kunta.. :D 
var channels_obj = Object.create(null);
channels_obj.channel_list = [];//Channel list
channels_obj.buffer = Object.create(null);

channels_obj.init = function(){
};//Initializes channel object

channels_obj.createChannel = function(channelId){
};//Adds a new channel

channels_obj.translate = function(msg,userSock){
	var tempCmd = JSON.parse(msg);
	switch (tempCmd.command) {
		case "createChannel" : 
			try{
				if(channels[tempCmd.channelId] = channel(tempCmd.pass))	console.log("Channel Creation Successful\n");
				else console.log("Channel Already exists");
			}catch(e){
				console.log("Error Has occured during channel creation \n");
			}
		break;
		
		case "destroyChannel":
			try{
				for (var i in channels)
					if(i==tempCmd.channelId) channels.splice(i,1);
				console.log("Channel Destruction Successful\n");
			}catch(e){
				console.log("Error Has occured during channel destruction\n : "+e);
			}
		break;
		
		case "subscribe" : 
			try{
				if(channels[tempCmd.channelId].subscribe(userSock))	console.log("Subscription Successful\n");
				else throw "Subscriber Already Exists";
			}catch(e){
				console.log("Error Has occured during subscription\n" + e);
			}
		break;
		
		case "unsubscribe" : 
			try{
				channels[tempCmd.channelId].unsubscribe(userSock);
				console.log("Unsubscription Successful\n");
			}catch(e){
				console.log("Error Has occured during unsubscription\n"+e);
			}
		break;
		
		case "showStats" : 
			try{
				console.log(channels[tempCmd.channelId].stats());
			}catch(e){
				console.log("The following error occured\n"+e);
			}
		break;
		
		default:
			try{ 
				channels[tempCmd.channelId].broadcast(tempCmd.data);
			}catch(e){
				console.log("The following error occured\n"+e);
			}
		break;
	}
};//This contains an optional message processor class

channels_obj.purge = function(channelId){
};//purges a channel

channels_obj.broadcast = function(channelId,msg){
};//Traditionally broadcast to all players in a channel.

channels_obj.bare_broadcast = function(){
};//Broadcast stripped down message (non JSON format) to users

channels_obj.checkTimeout = function(){
};//Checks if the timeout has been passed

channels_obj.timestamp = function(){
};

channels_obj.buffer.init = function(){

};

channels_obj.buffer.buf = [];
channels_obj.buffer.tracker = 0;
channels_obj.buffer.limit = 100;
channels_obj.buffer.trigger = 20;

channels_obj.buffer.load = function(data){
		this.buf.push(data);
		this.tracker = this.buf.length;
};

channels_obj.buffer.play = function(){
		var start = 0;
		if (this.buf.length >this.limit){
				var deleteCount = this.limit;
		} else {
				var deleteCount = this.buf.length;
		}
		temp_buffer = this.buf.splice(start,deleteCount);
		
		
		return 0;
};

//Channel sub object
channels_obj.channel = Object.create(null);//Naked Channel Object
channels_obj.channel.timestamp = 0;//Adds a timestamp to the channel
channels_obj.channel.channelPass = '';
channels_obj.channel.subscribers = [];

channels_obj.channel.subscribe = function(){
	for(var i in this.subscribers) if(this.subscribers[i]==sock) return 0;
		this.subscribers.push(sock);
	return 1;
};//subscribe a user to a channel

channels_obj.channel.broadcast = function(){
	for (var i in this.subscribers)
		 this.subscribers[i].send(msg);
	return 1;	
};//Broadcasting a message to a specific channel

Object.freeze(channels_obj);
module.exports.channels_obj = channels_obj;


//ZMQ interproc Communication Handler
var zmq = require('zmq'),
publisher = zmq.socket('pub'),
subscriber = zmq.socket('sub'),
xsubSock = zmq.socket('xsub'),
xpubSock = zmq.socket('xpub'),
pubListener = 'tcp://127.0.0.1:10001',
subListener = 'tcp://127.0.0.1:10002',
hwm = 1000,
verbose = 0,
comms = Object.create(null);

comms.init = function(handle_func){
	this.pub_broker_init();
	this.sub_init(handle_func);
};//Initialization function

comms.pub_broker_init = function(){
	try {
		// The xsub listener is where pubs connect to
		xsubSock.identity = 'subscriber' + process.pid;
		xsubSock.bindSync(pubListener,function(err){
			logger.logErr(err);
		});
				
		console.log("X Publisher Listener Established");

		// The xpub listener is where subs connect to
		xpubSock.identity = 'publisher' + process.pid;
		xpubSock.setsockopt(zmq.ZMQ_SNDHWM, hwm);
		// By default xpub only signals new subscriptions
		// Settings it to verbose = 1 , will signal on every new subscribe
		xpubSock.setsockopt(zmq.ZMQ_XPUB_VERBOSE, verbose);
		xpubSock.bindSync(subListener,function(err){
			logger.logErr(err);
		});

		console.log("X Subscriber Listener Established"); 

		// When we receive data on subSock , it means someone is publishing
		xsubSock.on('message', function(data) {
	    // We just relay it to the pubSock, so subscribers can receive it
			xpubSock.send(data);
		});
				 
		// When Pubsock receives a message , it's subscribe requests
		xpubSock.on('message', function(data, bla) {
	    	// The data is a slow Buffer
			// The first byte is the subscribe (1) /unsubscribe flag (0)
			var type = data[0]===0 ? 'unsubscribe' : 'subscribe';
			// The channel name is the rest of the buffer
			var channel = data.slice(1).toString();
			console.log(type + ':' + channel);
			// We send it to subSock, so it knows to what channels to listen to
			xsubSock.send(data);
		});

		publisher.connect(pubListener,function(err){
			if(err)
			logger.logErr(err);
		});

		console.log("Listening on 8688...");

	}
	catch (e) {
		publisher.connect(pubListener,function(err){
			if(err)
				logger.logErr(err);
		});
		console.log("Listening on 8688...");
	}
};//Initialize xpub/xsub broker

comms.sub_init = function(handle_func){
	subscriber.connect(subListener, function(err){
		console.log(err);
		logger.logErr(err);
	});
	subscriber.subscribe("");
	subscriber.on("message",handle_func);
	console.log("Subscribed to empty channel");
	logger.logStat("Subscribed to empty channel");
};//Subscribes to socket, the subscriber message handling will be defined 
	
comms.transmit = function(msg){
	publisher.send(msg);
	return 1;
};//Transmits messages to all nodes

Object.freeze(comms);
module.exports.comms = comms;


//Log Handler: This will manage custom error messages for platform errors.
//The messages are coded to make it lighter for smaller devics
var winston = require('winston'),
logger = Object.create(null);

var log_object = '';

logger.init = function(){
	log_object = new (winston.Logger)({
		transports: [
			new (winston.transports.File)({
				name: 'error-file',
				filename: 'logs/errors.log',
				level: 'error',
				handleExceptions: true
			}),
			new (winston.transports.File)({
				name: 'info-file',
				filename: 'logs/stats.log',
				level: 'info'
			}) 
		]
	});
};

logger.logStat = function(tmp){
	log_object.info(tmp);
};

logger.logErr = function(tmp){
	log_object.error(tmp);
};

logger.logDebug = function(tmp){
	log_object.debug(tmp);
};

Object.freeze(logger);
module.exports.logger = logger;

