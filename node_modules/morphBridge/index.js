/* Morph Bridge Application module. 
Created By: Phillip Ochola Mak'Anyengo,
Email: its2uraps@gmail.com, 
Github: https://github.com/its2mc,
License: 
*/


//Channel Object. This is the King Kunta.. :D 
var channels_obj = Object.create(null);
channels_obj.channel_list = [];//Channel list
channels_obj.buffer = Object.create(null);

channels_obj.init = function(){
};// Initializes channel object

channels_obj.createChannel = function(channelId){
};// Adds a new channel

channels_obj.translate = function(msg,userSock){
	var tempCmd = JSON.parse(msg);
	switch (tempCmd.command) {
		case "1" : //Create Channel
			try{
				if(channels[tempCmd.channelId] = channel(tempCmd.pass))	
					logger.logStat("Channel Creation Successful");
				else logger.logStat("Channel Already exists");
			}catch(e){
				logger.logErr("Error Has occured during channel creation");
			}
		break;
		
		case "2": //Destroy Channel
			try{
				for (var i in channels)
					if(i==tempCmd.channelId) channels.splice(i,1);
				logger.logStat("Channel Destruction Successful");
			}catch(e){
				logger.logErr("Error Has occured during channel destruction : "+e);
			}
		break;
		
		case "3" : //Subscribe
			try{
				if(channels[tempCmd.channelId].subscribe(userSock))
					logger.logStat("Subscription Successful");
				else throw "Subscriber Already Exists";
			}catch(e){
				logger.logErr("Error Has occured during subscription" + e);
			}
		break;
		
		case "4" : //Unsubscribe
			try{
				channels[tempCmd.channelId].unsubscribe(userSock);
				logger.logStat("Unsubscription Successful");
			}catch(e){
				logger.logErr("Error Has occured during unsubscription"+e);
			}
		break;
		
		default:
			try{ 
				channels[tempCmd.channelId].broadcast(tempCmd.data);
			}catch(e){
				logger.logErr("The following error occured"+e);
			}
		break;
	}
};// This contains an optional message processor class

channels_obj.purge = function(channelId){
};// Purges a channel

channels_obj.checkTimeout = function(){

};// Checks if the timeout has been passed

channels_obj.timestamp = function(){

};// Update the active time for a channel

channels_obj.stats = function(){

};// Give a full list of channels and their subscribers

channels_obj.buffer.init = function(){

};// Initialize a buffer

channels_obj.buffer.loadMsg = function(data){
		this.buf.push(data);
		this.tracker = this.buf.length;
};// Load a message into the buffer

channels_obj.buffer.extractMsg = function(){
		var start = 0;
		temp_buffer = this.buf.splice(start,this.buf.length);
		return 0;
};// Remove the messages loaded into the buffer


//Channel sub object
channels_obj.channel = Object.create(null);//Naked Channel Object
channels_obj.channel.timestamp = 0;//Adds a timestamp to the channel
channels_obj.channel.channelPass = '';
channels_obj.channel.subscribers = [];

channels_obj.channel.subscribe = function(){
	for(var i in this.subscribers) if(this.subscribers[i]==sock) return 0;
		this.subscribers.push(sock);
	return 1;
};// Subscribe a user to a channel

channels_obj.channel.broadcast = function(channelId,msg){
	for (var i in this.subscribers)
		 this.subscribers[i].send(msg);
	return 1;	
};// Broadcasting a message to a specific channel

channels_obj.channel.bare_broadcast = function(channelId,msg){
	for (var i in this.subscribers)
		 this.subscribers[i].send(msg);
	return 1;	
};// Broadcast stripped down message (non JSON format)

Object.freeze(channels_obj);
module.exports.channels_obj = channels_obj;


//ZMQ interproc Communication Handler
var zmq = require('zmq'),
publisher = zmq.socket('pub'),
subscriber = zmq.socket('sub'),
pubListener = 'tcp://127.0.0.1:10001',
subListener = 'tcp://127.0.0.1:10002',
monitor = "",
handle_function = "",
hwm = 1000,
verbose = 0,
restartAttempts = 1,
comms = Object.create(null),
exec = require('child_process').exec;

comms.init = function(handle_func){
	handle_function = handle_func;
	this.pub_broker_init(this.pub_init);
	this.sub_init(handle_func);
};// Initialization function

comms.pub_broker_init = function(handle_func){
	exec('node _proxy.js', function(err, stdout, stderr) {
		// the command exited or the launching failed
		if (err) {
			// we had an error launching the process
			logger.logErr('child process exited with error code', err);
			return;
		}
		logger.logStat('Successfully Restarted Thread');
	});
	setTimeout(function() {
   		console.log('Communication started');
		handle_func();
	}, 500);
	
};// Initialize xpub/xsub broker

comms.pub_init = function(){
	publisher.connect(pubListener,function(err){
		if(err)
			logger.logErr(err);
	});
	comms.monitor();
	logger.logStat("Enabled Publisher");
};// Initializes Publisher Socket

comms.sub_init = function(handle_func){
	subscriber.connect(subListener, function(err){
		logger.logErr(err);
	});
	subscriber.subscribe("");
	subscriber.on("message",handle_func);
	logger.logStat("Enabled Subscriber");
	logger.logStat("Subscribed to empty channel");
};// Subscribes to socket, the subscriber message handling will be defined 
	
comms.monitor = function(){
	var count = 0;
	publisher.monitor(500,0);
	console.log("Enabled Monitor");
	publisher.on('close', function(fd, ep) {
		if(count < restartAttempts){
			console.log("Restarting communciations.");
			exec('node _proxy.js', function(err, stdout, stderr) {
				// the command exited or the launching failed
				if (err) {
					// we had an error launching the process
					logger.logErr('child process exited with error code', err);
					return;
				}
				logger.logStat('Successfully Restarted Thread');
			});
			console.log("communications restarted");
			count++;
		}
	});
};// Monitor the Infrastructure to Restart incase of Exit by one node	

comms.transmit = function(msg){
	publisher.send(msg);
	return 1;
};// Transmits messages to all nodes

comms.close = function(){
	publisher.unmonitor();
	publisher.close();
	subscriber.close();
};//Closes all sockets and connections in case of SIGINT

Object.freeze(comms);
module.exports.comms = comms;


//Log Handler: This will manage custom error messages for platform errors.
//The messages are coded to make it lighter for smaller devics
var winston = require('winston'),
logger = Object.create(null);

var log_object = '';

logger.init = function(){
	log_object = new (winston.Logger)({
		transports: [
			new (winston.transports.File)({
				name: 'error-file',
				filename: 'logs/errors.log',
				level: 'error',
				handleExceptions: true
			}),
			new (winston.transports.File)({
				name: 'info-file',
				filename: 'logs/stats.log',
				level: 'info'
			}) 
		]
	});
};

logger.logStat = function(tmp){
	log_object.info(tmp);
};

logger.logErr = function(tmp){
	log_object.error(tmp);
};

logger.logDebug = function(tmp){
	log_object.debug(tmp);
};

Object.freeze(logger);
module.exports.logger = logger;

